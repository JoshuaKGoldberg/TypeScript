=== tests/cases/conformance/types/difference/objectRest.ts ===

let o = { a: 1, b: 'no' }
>o : { a: number; b: string; }
>{ a: 1, b: 'no' } : { a: number; b: string; }
>a : number
>1 : 1
>b : string
>'no' : "no"

var { ...clone } = o;
>clone : { a: number; b: string; }
>o : { a: number; b: string; }

var { a, ...justB } = o;
>a : number
>justB : { b: string; }
>o : { a: number; b: string; }

var { a, b: renamed, ...empty } = o;
>a : number
>b : any
>renamed : string
>empty : {}
>o : { a: number; b: string; }

var { ['b']: renamed, ...justA } = o;
>'b' : "b"
>renamed : string
>justA : { a: number; }
>o : { a: number; b: string; }

var { 'b': renamed, ...justA } = o;
>renamed : string
>justA : { a: number; }
>o : { a: number; b: string; }

var { b: { '0': n, '1': oooo }, ...justA } = o;
>b : any
>n : string
>oooo : string
>justA : { a: number; }
>o : { a: number; b: string; }

let o2 = { c: 'terrible idea?', d: 'yes' };
>o2 : { c: string; d: string; }
>{ c: 'terrible idea?', d: 'yes' } : { c: string; d: string; }
>c : string
>'terrible idea?' : "terrible idea?"
>d : string
>'yes' : "yes"

var { d: renamed, ...d } = o2;
>d : any
>renamed : string
>d : { c: string; }
>o2 : { c: string; d: string; }

let nestedrest: { x: number, n1: { y: number, n2: { z: number, n3: { n4: number } } }, rest: number, restrest: number };
>nestedrest : { x: number; n1: { y: number; n2: { z: number; n3: { n4: number; }; }; }; rest: number; restrest: number; }
>x : number
>n1 : { y: number; n2: { z: number; n3: { n4: number; }; }; }
>y : number
>n2 : { z: number; n3: { n4: number; }; }
>z : number
>n3 : { n4: number; }
>n4 : number
>rest : number
>restrest : number

var { x, n1: { y, n2: { z, n3: { ...nr } } }, ...restrest } = nestedrest;
>x : number
>n1 : any
>y : number
>n2 : any
>z : number
>n3 : any
>nr : { n4: number; }
>restrest : { rest: number; restrest: number; }
>nestedrest : { x: number; n1: { y: number; n2: { z: number; n3: { n4: number; }; }; }; rest: number; restrest: number; }

let complex: { x: { ka, ki }, y: number };
>complex : { x: { ka: any; ki: any; }; y: number; }
>x : { ka: any; ki: any; }
>ka : any
>ki : any
>y : number

var { x: { ka, ...nested }, y: other, ...rest } = complex;
>x : any
>ka : any
>nested : { ki: any; }
>y : any
>other : number
>rest : {}
>complex : { x: { ka: any; ki: any; }; y: number; }

({x: { ka, ...nested }, y: other, ...rest} = complex);
>({x: { ka, ...nested }, y: other, ...rest} = complex) : { x: { ka: any; ki: any; }; y: number; }
>{x: { ka, ...nested }, y: other, ...rest} = complex : { x: { ka: any; ki: any; }; y: number; }
>{x: { ka, ...nested }, y: other, ...rest} : { x: { ki: any; ka: any; }; y: number; }
>x : { ki: any; ka: any; }
>{ ka, ...nested } : { ki: any; ka: any; }
>ka : any
>nested : any
>y : number
>other : number
>rest : any
>complex : { x: { ka: any; ki: any; }; y: number; }

