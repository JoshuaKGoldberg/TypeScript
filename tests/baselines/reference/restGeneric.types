=== tests/cases/conformance/types/rest/restGeneric.ts ===
interface Gen {
>Gen : Gen

    x: number;
>x : number
}
interface Gen2 {
>Gen2 : Gen2

    parent: Gen;
>parent : Gen
>Gen : Gen

    millenial: string;
>millenial : string
}
function cloneAgain<T extends Gen & Gen2>(t: T): T - (x) {
>cloneAgain : <T extends Gen & Gen2>(t: T) => T - ( x )
>T : T
>Gen : Gen
>Gen2 : Gen2
>t : T
>T : T
>T : T

    // declarations with generics create difference types
    let rest: T - (x);
>rest : T - ( x )
>T : T

    let rest1: T - (x) - (parent, millenial);
>rest1 : T - ( x ) - ( parent, millenial )
>T : T

    var { x, parent, ...rest2 } = t;
>x : number
>parent : Gen
>rest2 : T - ( x, parent )
>t : T

    // apparent types distribute the intersection constraint correctly
    rest.parent;
>rest.parent : Gen
>rest : T - ( x )
>parent : Gen

    rest.millenial;
>rest.millenial : string
>rest : T - ( x )
>millenial : string

    rest2.millenial;
>rest2.millenial : string
>rest2 : T - ( x, parent )
>millenial : string

    ({ x, parent, ...rest2 } = t);
>({ x, parent, ...rest2 } = t) : T
>{ x, parent, ...rest2 } = t : T
>{ x, parent, ...rest2 } : { x: number; parent: Gen; ...T - ( x, parent ) }
>x : number
>parent : Gen
>rest2 : any
>t : T

    return rest2; // TODO: T - (x, parent) shouldn't be assignable to T - (x)
>rest2 : T - ( x, parent )
}
interface Gen3 extends Gen2 {
>Gen3 : Gen3
>Gen2 : Gen2

    x: number;
>x : number

    w: boolean;
>w : boolean
}
let gen3: Gen3;
>gen3 : Gen3
>Gen3 : Gen3

let rested = cloneAgain(gen3);
>rested : { w: boolean; parent: Gen; millenial: string; }
>cloneAgain(gen3) : { w: boolean; parent: Gen; millenial: string; }
>cloneAgain : <T extends Gen & Gen2>(t: T) => T - ( x )
>gen3 : Gen3

rested.parent;
>rested.parent : Gen
>rested : { w: boolean; parent: Gen; millenial: string; }
>parent : Gen

rested.millenial;
>rested.millenial : string
>rested : { w: boolean; parent: Gen; millenial: string; }
>millenial : string

rested.w;
>rested.w : boolean
>rested : { w: boolean; parent: Gen; millenial: string; }
>w : boolean

